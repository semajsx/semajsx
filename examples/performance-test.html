<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SemaJSX Performance Test</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
    }

    .section {
      margin: 30px 0;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }

    h2 {
      margin-top: 0;
      color: #333;
    }

    button {
      margin: 5px;
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background: #0056b3;
    }

    .item {
      padding: 8px;
      margin: 4px 0;
      background: #f8f9fa;
      border-left: 3px solid #007bff;
    }

    .stats {
      margin-top: 10px;
      padding: 10px;
      background: #e9ecef;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>SemaJSX Performance Optimizations Test</h1>

  <div class="section">
    <h2>1. Batching Test</h2>
    <p>Updates multiple signals at once - should only trigger one DOM update (check console)</p>
    <div id="batch-test"></div>
  </div>

  <div class="section">
    <h2>2. Keyed List Test</h2>
    <p>Efficiently updates lists using keys - items should be reused, not recreated</p>
    <div id="list-test"></div>
  </div>

  <div class="section">
    <h2>3. DOM Node Pooling Test</h2>
    <p>Reuses DOM nodes instead of replacing them - same text node instance is updated</p>
    <div id="pool-test"></div>
  </div>

  <script type="module">
    import { signal, computed, batch } from '../dist/signal/index.js';
    import { render } from '../dist/dom/index.js';
    import { h } from '../dist/dom/jsx-runtime.js';

    // Test 1: Batching
    {
      const count1 = signal(0);
      const count2 = signal(0);
      const count3 = signal(0);

      const total = computed([count1, count2, count3], (a, b, c) => a + b + c);

      let updateCount = 0;

      function BatchTest() {
        // Track updates
        updateCount = 0;
        const renderCount = signal(0);

        total.subscribe(() => {
          updateCount++;
          renderCount.value = updateCount;
        });

        return h('div', null,
          h('p', null, 'Count 1: ', count1),
          h('p', null, 'Count 2: ', count2),
          h('p', null, 'Count 3: ', count3),
          h('p', null, 'Total: ', total),
          h('div', { class: 'stats' }, 'DOM Updates: ', renderCount),
          h('button', {
            onclick: () => {
              // Without batching, this would cause 3 updates
              // With batching, should only cause 1 update
              console.log('Before batch update');
              batch(() => {
                count1.value++;
                count2.value++;
                count3.value++;
              });
              console.log('After batch update - check that only 1 update occurred');
            }
          }, 'Update All (Batched)'),
          h('button', {
            onclick: () => {
              // Without batching, causes 3 separate updates
              console.log('Before separate updates');
              count1.value++;
              count2.value++;
              count3.value++;
              console.log('After separate updates - check microtask batching');
            }
          }, 'Update All (Separate)')
        );
      }

      render(h(BatchTest, null), document.getElementById('batch-test'));
    }

    // Test 2: Keyed Lists
    {
      const items = signal([
        { id: 1, text: 'Item 1' },
        { id: 2, text: 'Item 2' },
        { id: 3, text: 'Item 3' },
        { id: 4, text: 'Item 4' },
      ]);

      function ListTest() {
        return h('div', null,
          computed([items], (list) =>
            h('div', null,
              ...list.map(item =>
                h('div', { key: item.id, class: 'item' },
                  `${item.text} (ID: ${item.id})`
                )
              )
            )
          ),
          h('button', {
            onclick: () => {
              // Reverse the list - with keyed reconciliation, DOM nodes are moved, not recreated
              items.value = [...items.peek()].reverse();
              console.log('List reversed - DOM nodes should be moved, not recreated');
            }
          }, 'Reverse'),
          h('button', {
            onclick: () => {
              // Shuffle
              const arr = [...items.peek()];
              for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
              }
              items.value = arr;
              console.log('List shuffled - existing items reused');
            }
          }, 'Shuffle'),
          h('button', {
            onclick: () => {
              // Add item
              const newId = Math.max(...items.peek().map(i => i.id)) + 1;
              items.value = [...items.peek(), { id: newId, text: `Item ${newId}` }];
              console.log('Item added');
            }
          }, 'Add Item'),
          h('button', {
            onclick: () => {
              // Remove first item
              if (items.peek().length > 0) {
                items.value = items.peek().slice(1);
                console.log('First item removed');
              }
            }
          }, 'Remove First')
        );
      }

      render(h(ListTest, null), document.getElementById('list-test'));
    }

    // Test 3: DOM Node Pooling
    {
      const text = signal('Hello World');
      const counter = signal(0);

      function PoolTest() {
        return h('div', null,
          h('p', null, 'Text: ', text),
          h('p', null, 'Counter: ', counter),
          h('p', { style: 'color: green; font-weight: bold;' },
            computed([counter], c => c % 2 === 0 ? 'Even' : 'Odd')
          ),
          h('button', {
            onclick: () => {
              text.value = text.peek() + '!';
              console.log('Text updated - text node should be reused, not replaced');
            }
          }, 'Add Exclamation'),
          h('button', {
            onclick: () => {
              counter.value++;
              console.log('Counter updated - nodes should be pooled');
            }
          }, 'Increment'),
          h('button', {
            onclick: () => {
              // Reset
              text.value = 'Hello World';
              counter.value = 0;
            }
          }, 'Reset')
        );
      }

      render(h(PoolTest, null), document.getElementById('pool-test'));
    }

    console.log('Performance tests loaded! Open DevTools to see optimization details.');
  </script>
</body>
</html>
